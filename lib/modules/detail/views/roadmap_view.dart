import 'package:easy_refresh/easy_refresh.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_easyloading/flutter_easyloading.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:homing_pigeon/app/navigator.dart';
import 'package:homing_pigeon/common/api/roadmap_api.dart';
import 'package:homing_pigeon/common/enums/enums.dart';
import 'package:homing_pigeon/common/extensions/single.dart';
import 'package:homing_pigeon/common/http/utils/handle_errors.dart';
import 'package:homing_pigeon/common/logger/logger.dart';
import 'package:homing_pigeon/common/models/models.dart';
import 'package:homing_pigeon/common/utils/color_util.dart';
import 'package:homing_pigeon/common/utils/navigator_util.dart';
import 'package:homing_pigeon/common/utils/string_util.dart';
import 'package:homing_pigeon/common/widgets/widgets.dart';
import 'package:homing_pigeon/i18n/i18n.dart';
import 'package:homing_pigeon/theme/colors.dart';
import 'package:markdown/markdown.dart' as md;
import 'package:syncfusion_flutter_calendar/calendar.dart';

const String _notes = """
# Basic Markdown Demo
---
The Basic Markdown Demo shows the effect of the four Markdown extension sets
on formatting basic and extended Markdown tags.

Insert emoji :smiley: here, `哈哈哈哈`

```demo.dart
void main() {

}
```

## Overview

The Dart [markdown](https://pub.dev/packages/markdown) package parses Markdown
into HTML. The flutter_markdown package builds on this package using the
abstract syntax tree generated by the parser to make a tree of widgets instead
of HTML elements.

The markdown package supports the basic block and inline Markdown syntax
specified in the original Markdown implementation as well as a few Markdown
extensions. The markdown package uses extension sets to make extension
management easy. There are four pre-defined extension sets; none, Common Mark,
GitHub Flavored, and GitHub Web. The default extension set used by the
flutter_markdown package is GitHub Flavored.

The Basic Markdown Demo shows the effect each of the pre-defined extension sets
has on a test Markdown document with basic and extended Markdown tags. Use the
Extension Set dropdown menu to select an extension set and view the Markdown
widget's output.

## Comments

Since GitHub Flavored is the default extension set, it is the initial setting
for the formatted Markdown view in the demo.
""";

class RoadmapView extends StatefulWidget {
  const RoadmapView({super.key});

  @override
  State<RoadmapView> createState() => _RoadmapViewState();
}

class _RoadmapViewState extends State<RoadmapView> {
  final EasyRefreshController _controller = EasyRefreshController(
    controlFinishRefresh: true,
    controlFinishLoad: true,
  );
  final ScrollController _scrollController = ScrollController();

  List<RoadmapModel> _items = [];
  DateTime _current = DateTime.now();
  bool _initialized = false;

  @override
  void initState() {
    super.initState();
    _load(year: _current.year, month: _current.month);
  }

  @override
  void dispose() {
    _controller.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final t = Translations.of(context);
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final height = MediaQuery.sizeOf(context).height;
    final top = MediaQuery.paddingOf(context).top;
    return Scaffold(
      appBar: HpAppBar(
        isDark: isDark,
        titleName: t.pages.roadmap.title,
      ),
      body: EasyRefresh(
        controller: _controller,
        header: const ClassicHeader(),
        onRefresh: () => _load(
          year: _current.year,
          month: _current.month,
          operation: Operation.refresh,
        ),
        child: SfCalendar(
          view: CalendarView.timelineMonth,
          dataSource: RoadmapDataSource(_items),
          onViewChanged: (ViewChangedDetails viewChangedDetails) {
            final visibleDates = viewChangedDetails.visibleDates;
            if (kDebugMode) {
              print('visibleDates: ${viewChangedDetails.visibleDates}');
            }
            if (visibleDates.isNotEmpty && _initialized) {
              final startDate = visibleDates.first;
              printDebugLog('startDate: $startDate');
              setState(() => _current = startDate);
              _load(year: startDate.year, month: startDate.month);
            }
          },
          onTap: (CalendarTapDetails calendarTapDetails) {
            final appointments = calendarTapDetails.appointments;
            if (appointments != null && appointments.isNotEmpty) {
              final appointment = calendarTapDetails.appointments!.first;
              if (appointment is RoadmapModel) {
                if (kDebugMode) {
                  print(appointment.title);
                }
                showCalendarModalBottomSheet(appointment);
              }
            }
          },
          showNavigationArrow: _initialized,
          showDatePickerButton: _initialized,
          showTodayButton: _initialized,
          // allowViewNavigation: true,
          showWeekNumber: _initialized,
          // allowAppointmentResize: true,
          headerDateFormat: 'MM/yyyy',
          monthViewSettings: const MonthViewSettings(
            appointmentDisplayCount: 5,
            appointmentDisplayMode: MonthAppointmentDisplayMode.appointment,
          ),
        )
            .nestedSizedBox(height: height - top - kToolbarHeight)
            .nestedSingleChildScrollView(),
      ),
    );
  }

  /// 数据加载
  void _load({
    required int year,
    required int month,
    Operation operation = Operation.none,
  }) {
    if (operation == Operation.none) {
      EasyLoading.show();
    }
    RoadmapApi.getRoadmapList(year: year, month: month - 1).then(
      (data) {
        if (operation == Operation.none) {
          EasyLoading.dismiss();
        } else if (operation == Operation.refresh) {
          _controller.finishRefresh();
        }
        setState(() {
          _initialized = true;
          _items = data;
        });
      },
    ).onError<Exception>((error, stackTrace) {
      final context = AppNavigator.key.currentContext!;
      final t = Translations.of(context);
      ErrorHandler.handle(
        error,
        stackTrace: stackTrace,
        postProcessor: (_, msg) {
          setState(() => _items = []);
          if (operation == Operation.none) {
            EasyLoading.showError(msg ?? t.common.failure);
          } else if (operation == Operation.refresh) {
            _controller.finishRefresh(IndicatorResult.fail);
          }
        },
      );
    });
  }

  void showCalendarModalBottomSheet(RoadmapModel roadmap) {
    final t = Translations.of(context);
    showModalBottomSheet<void>(
      context: context,
      isDismissible: false,
      isScrollControlled: true,
      enableDrag: false,
      builder: (BuildContext context) => ModalBottomSheet(
        buttonText: t.buttons.turnOff,
        contentPadding: const EdgeInsets.symmetric(horizontal: 10),
        margin: const EdgeInsets.symmetric(vertical: 10),
        callback: NavigatorUtil.pop,
        items: [
          Markdown(
            controller: _scrollController,
            selectable: true,
            data: _notes,
            shrinkWrap: true,
            padding: EdgeInsets.zero,
            extensionSet: md.ExtensionSet(
              <md.BlockSyntax>[
                const md.OrderedListSyntax(),
                const md.UnorderedListSyntax(),
                const md.BlockquoteSyntax(),
                const md.CodeBlockSyntax(),
                ...md.ExtensionSet.gitHubWeb.blockSyntaxes,
              ],
              <md.InlineSyntax>[
                md.DecodeHtmlSyntax(),
                md.CodeSyntax(),
                ...md.ExtensionSet.gitHubWeb.inlineSyntaxes,
              ],
            ),
          ).nestedPadding(
            padding: const EdgeInsets.symmetric(vertical: 10),
          ),
        ],
      ),
    );
  }
}

class RoadmapDataSource extends CalendarDataSource<RoadmapModel> {
  /// Creates a meeting data source, which used to set the appointment
  /// collection to the calendar
  RoadmapDataSource(List<RoadmapModel> source) {
    appointments = source;
  }

  @override
  DateTime getStartTime(int index) {
    return _getItem(index).from ?? DateTime.now();
  }

  @override
  DateTime getEndTime(int index) {
    return _getItem(index).to ?? DateTime.now();
  }

  @override
  String getSubject(int index) {
    return _getItem(index).title ?? 'Item: $index';
  }

  @override
  Color getColor(int index) {
    return ColorUtil.stringToColor(
      StringUtil.getValue(_getItem(index).background),
      placeholderTextColor,
    );
  }

  @override
  bool isAllDay(int index) {
    return _getItem(index).isAllDay;
  }

  RoadmapModel _getItem(int index) {
    final dynamic roadmap = appointments![index];
    late final RoadmapModel roadmapData;
    if (roadmap is RoadmapModel) {
      roadmapData = roadmap;
    }

    return roadmapData;
  }
}
