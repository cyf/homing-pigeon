import 'dart:convert';

import 'package:easy_refresh/easy_refresh.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_easyloading/flutter_easyloading.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:flutter_quill/flutter_quill.dart' hide Operation;
import 'package:homing_pigeon/common/api/roadmap_api.dart';
import 'package:homing_pigeon/common/enums/enums.dart';
import 'package:homing_pigeon/common/exception/exception.dart';
import 'package:homing_pigeon/common/extensions/single.dart';
import 'package:homing_pigeon/common/logger/logger.dart';
import 'package:homing_pigeon/common/models/models.dart';
import 'package:homing_pigeon/common/utils/color_util.dart';
import 'package:homing_pigeon/common/utils/navigator_util.dart';
import 'package:homing_pigeon/common/utils/string_util.dart';
import 'package:homing_pigeon/common/widgets/widgets.dart';
import 'package:homing_pigeon/theme/colors.dart';
import 'package:markdown/markdown.dart' as md;
import 'package:syncfusion_flutter_calendar/calendar.dart';

const String _notes = """
# Basic Markdown Demo
---
The Basic Markdown Demo shows the effect of the four Markdown extension sets
on formatting basic and extended Markdown tags.

Insert emoji :smiley: here, `哈哈哈哈`

```demo.dart
void main() {

}
```

## Overview

The Dart [markdown](https://pub.dev/packages/markdown) package parses Markdown
into HTML. The flutter_markdown package builds on this package using the
abstract syntax tree generated by the parser to make a tree of widgets instead
of HTML elements.

The markdown package supports the basic block and inline Markdown syntax
specified in the original Markdown implementation as well as a few Markdown
extensions. The markdown package uses extension sets to make extension
management easy. There are four pre-defined extension sets; none, Common Mark,
GitHub Flavored, and GitHub Web. The default extension set used by the
flutter_markdown package is GitHub Flavored.

The Basic Markdown Demo shows the effect each of the pre-defined extension sets
has on a test Markdown document with basic and extended Markdown tags. Use the
Extension Set dropdown menu to select an extension set and view the Markdown
widget's output.

## Comments

Since GitHub Flavored is the default extension set, it is the initial setting
for the formatted Markdown view in the demo.
""";

class RoadmapView extends StatefulWidget {
  const RoadmapView({super.key});

  @override
  State<RoadmapView> createState() => _RoadmapViewState();
}

class _RoadmapViewState extends State<RoadmapView> {
  final EasyRefreshController _controller = EasyRefreshController(
    controlFinishRefresh: true,
    controlFinishLoad: true,
  );
  final QuillController _quillController = QuillController.basic();
  final ScrollController _scrollController = ScrollController();

  List<RoadmapModel> _items = [];
  DateTime _current = DateTime.now();
  bool _initialized = false;

  @override
  void initState() {
    super.initState();
    _load(year: _current.year, month: _current.month);
  }

  @override
  void dispose() {
    _controller.dispose();
    _quillController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final height = MediaQuery.of(context).size.height;
    final top = MediaQuery.of(context).padding.top;
    return Scaffold(
      appBar: HpAppBar(
        titleName: '路线图',
      ),
      body: EasyRefresh(
        controller: _controller,
        header: const ClassicHeader(),
        onRefresh: () => _load(
          year: _current.year,
          month: _current.month,
          operation: Operation.refresh,
        ),
        child: SfCalendar(
          view: CalendarView.timelineMonth,
          dataSource: RoadmapDataSource(_items),
          onViewChanged: (ViewChangedDetails viewChangedDetails) {
            final visibleDates = viewChangedDetails.visibleDates;
            if (kDebugMode) {
              print('visibleDates: ${viewChangedDetails.visibleDates}');
            }
            if (visibleDates.isNotEmpty && _initialized) {
              final startDate = visibleDates.first;
              printDebugLog('startDate: $startDate');
              setState(() => _current = startDate);
              _load(year: startDate.year, month: startDate.month);
            }
          },
          onTap: (CalendarTapDetails calendarTapDetails) {
            final appointments = calendarTapDetails.appointments;
            if (appointments != null && appointments.isNotEmpty) {
              final appointment = calendarTapDetails.appointments!.first;
              if (appointment is RoadmapModel) {
                if (kDebugMode) {
                  print(appointment.title);
                }
                showCalendarModalBottomSheet(appointment);
              }
            }
          },
          showNavigationArrow: _initialized,
          showDatePickerButton: _initialized,
          showTodayButton: _initialized,
          // allowViewNavigation: true,
          showWeekNumber: _initialized,
          // allowAppointmentResize: true,
          headerDateFormat: 'MM/yyyy',
          monthViewSettings: const MonthViewSettings(
            appointmentDisplayCount: 5,
            appointmentDisplayMode: MonthAppointmentDisplayMode.appointment,
          ),
        )
            .nestedSizedBox(height: height - top - kToolbarHeight)
            .nestedSingleChildScrollView(),
      ),
    );
  }

  void _load({
    required int year,
    required int month,
    Operation operation = Operation.none,
  }) {
    if (operation == Operation.none) {
      EasyLoading.show();
    }
    RoadmapApi.getRoadmapList(year: year, month: month - 1).then(
      (data) {
        if (operation == Operation.none) {
          EasyLoading.dismiss();
        } else if (operation == Operation.refresh) {
          _controller.finishRefresh();
        }
        setState(() {
          _initialized = true;
          _items = data;
        });
      },
    ).onError<RequestedException>((error, stackTrace) {
      printErrorStackLog(error, stackTrace);
      setState(() => _items = []);
      if (operation == Operation.none) {
        EasyLoading.showError(error.msg);
      } else if (operation == Operation.refresh) {
        _controller.finishRefresh(IndicatorResult.fail);
      }
    });
  }

  void showCalendarModalBottomSheet(RoadmapModel roadmap) {
    final json = jsonDecode(r'{"insert":"hello\n"}');
    _quillController.document = Document.fromJson([json]);

    showModalBottomSheet<void>(
      context: context,
      isDismissible: false,
      isScrollControlled: true,
      enableDrag: false,
      builder: (BuildContext context) => ModalBottomSheet(
        buttonText: '关闭',
        padding: const EdgeInsets.symmetric(horizontal: 10),
        margin: const EdgeInsets.symmetric(vertical: 10),
        callback: NavigatorUtil.pop,
        items: [
          Markdown(
            controller: _scrollController,
            selectable: true,
            data: _notes,
            shrinkWrap: true,
            padding: EdgeInsets.zero,
            extensionSet: md.ExtensionSet(
              <md.BlockSyntax>[
                const md.OrderedListSyntax(),
                const md.UnorderedListSyntax(),
                const md.BlockquoteSyntax(),
                const md.CodeBlockSyntax(),
                ...md.ExtensionSet.gitHubWeb.blockSyntaxes,
              ],
              <md.InlineSyntax>[
                md.DecodeHtmlSyntax(),
                md.CodeSyntax(),
                ...md.ExtensionSet.gitHubWeb.inlineSyntaxes,
              ],
            ),
          ).nestedPadding(
            padding: const EdgeInsets.symmetric(vertical: 10),
          ),
          QuillProvider(
            configurations: QuillConfigurations(
              controller: _quillController,
              sharedConfigurations: const QuillSharedConfigurations(
                locale: Locale('zh'),
              ),
            ),
            child: QuillEditor.basic(
              configurations: const QuillEditorConfigurations(
                readOnly: true,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class RoadmapDataSource extends CalendarDataSource<RoadmapModel> {
  /// Creates a meeting data source, which used to set the appointment
  /// collection to the calendar
  RoadmapDataSource(List<RoadmapModel> source) {
    appointments = source;
  }

  @override
  DateTime getStartTime(int index) {
    return _getItem(index).from ?? DateTime.now();
  }

  @override
  DateTime getEndTime(int index) {
    return _getItem(index).to ?? DateTime.now();
  }

  @override
  String getSubject(int index) {
    return _getItem(index).title ?? 'Item: $index';
  }

  @override
  Color getColor(int index) {
    return ColorUtil.stringToColor(
      StringUtil.getValue(_getItem(index).background),
      placeholderTextColor,
    );
  }

  @override
  bool isAllDay(int index) {
    return _getItem(index).isAllDay;
  }

  RoadmapModel _getItem(int index) {
    final dynamic roadmap = appointments![index];
    late final RoadmapModel roadmapData;
    if (roadmap is RoadmapModel) {
      roadmapData = roadmap;
    }

    return roadmapData;
  }
}
